<!-- -*- text -*- -->
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        
        <title>Boost.Parser: A Parser Combinator Library for C++</title>
        
        <link rel="stylesheet" href="reveal.js/dist/reset.css">
        <link rel="stylesheet" href="reveal.js/dist/reveal.css">
        <link rel="stylesheet" href="reveal.js/dist/theme/black.css">
        
        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">
    </head>
    <body>
        <div class="reveal">
        <div class="slides">
            <section data-markdown=""
                     data-separator="^====+$"
                     data-separator-vertical="^----+$"
                     data-notes="^Note:">
              <script type="text/template">
## Boost.Parser: A Parser Combinator Library for C++
### Zach Laine

----

### Why a new parser library?

----

The short answer:

Spirit 2 is great, but it is written using C++98 techology.  Spirit X3 is a
modernized, experimental update that is not fully documented, but has a single
design decision that makes it unusable for me.

My love of these libraries and my frustration with this staus quo led to my
writing Boost.Parser.
<!-- .element: class="fragment" -->

----

The longer answer is that ...

----

Spirit 2:

- Suffers from very long compile times
<!-- .element: class="fragment" -->
- Has error reporting that requires a lot of user intervention to work
<!-- .element: class="fragment" -->
- Requires user intervention, including a (long) recompile, to enable parse tracing
<!-- .element: class="fragment" -->

----

Spirit X3:

- Has rules that do not compose well -- the attributes produced by a rule can change depending on the context in which you use the rule
<!-- .element: class="fragment" -->
- Is missing many of the convenient interfaces to parsers that Spirit 2 had
<!-- .element: class="fragment" -->

----

Both libraries:

- Have Unicode support, but it is quite difficult to get working
<!-- .element: class="fragment" -->
- Are ranges-unfriendly
<!-- .element: class="fragment" -->

----

On the positive side, both libraries:

- Share the same rich set of parsers and combining operations
<!-- .element: class="fragment" -->
- Have nice semantics for how to get values out of a parse operation
<!-- .element: class="fragment" -->
- Are fun to use
<!-- .element: class="fragment" -->

----

So, the goal is to create a library in the same style as the Spirit libraries,
updated for newer C++ standards.

The new library should also try to improve and simplify the interface
whererver possible.
<!-- .element: class="fragment" -->

Just as importantly, the new library must retain the fun.
<!-- .element: class="fragment" -->

----

### The big picture

----

```c++
#include <boost/parser/parser.hpp>
#include <iostream>
#include <string>
int main(int argc, char const * argv[]) {
    namespace bp = boost::parser;
    auto const result =
        bp::parse(argv[1], bp::double_ % ',', bp::ws);
    if (result) {
        for (double x : *result)
            std::cout << x << "\n";
    } else {
        std::cout << "Parse failed.\n";
    }
}
```

----

Parser consists of these elements:

<ul>
<li>First-order parsers (e.g. `int_`)</li>
<!-- .element: class="fragment" -->
<li>Operator overloads (e.g. `*` for Kleene star)</li>
<!-- .element: class="fragment" -->
<li>Second-order parsers/directives (e.g. `if_(cond)[p]` or `string_view[p]`)</li>
<!-- .element: class="fragment" -->
<li>Semantic actions</li>
<!-- .element: class="fragment" -->
<li>Rules</li>
<!-- .element: class="fragment" -->
</ul>

----

Using an operator overload or second-order parser on one or more existing
parsers makes a new parser.

----

For example, the `>>` operator puts two parsers together to make a new parser
that parses the left parser, and then, if successful, parses the right parser.
Here, `int_`, `double_`, and `parser` are all parsers.  The first two are
provided by Parser, the third you see defined here.

```c++
namespace bp = boost::parser;
constexpr auto parser = bp::int_ >> bp::double_;
```

Any parser has all the operator overloads defined for it, and can be used in
any of the second-order parsers.
<!-- .element: class="fragment" -->

----

Every Parser-provided parser is small, and does not allocate.  Many of them
are monostates.

Each parser is an invocable object with two `call()` overloads.
<!-- .element: class="fragment" -->

----

Every parser has an associated attribute type.  An attribute is a value that
is produced as a result of the parse.  For example, our earlier parser has an
attribute type of `bp::tuple<int, double>`.

```c++
constexpr auto parser = bp::int_ >> bp::double_;
```

----

A parser might have no attribute associated with it.  It's attribute type is
not `void`, but a special not-an-atribute type `none`.  The lack of
`void`-producing parsers keeps the Parser logic simpler.

----

Once you have a parser, you use it by passing it to `parse()`.

```c++
constexpr auto parser = bp::int_ >> bp::double_;

auto result = bp::parse("42 13.0", parser, bp::ws); // (1, 2)

static_assert(std::same_as<
    decltype(result),
    std::optional<bp::tuple<int, double>>>);        // (3)

assert(result);
assert(*result == bp::tuple(42, 13.0));
```

----

If the parser that you pass to `parse()` has no attribute, `parse()` returns a
`bool`.

----

You can also pass an attribute out-argument to `parse()`.

```c++
constexpr auto parser = bp::int_ >> bp::double_;

bp::tuple<int, double> result;
bool success = bp::parse("42 13.0", parser, bp::ws, result);

assert(success);
assert(result == bp::tuple(42, 13.0));
```

----

The attribute out-arg does not have to be the same type as the parser's
default attribute.

```c++
constexpr auto parser = bp::int_ >> bp::double_;

bp::tuple<char32_t, float> result;
bool success = bp::parse("42 13.0", parser, bp::ws, result);

assert(success);
assert(result == bp::tuple(char32_t(42), 13.0f));
```

----

This is why each parser has two `call()` overloads.  One is for when the
parser generates an attribute, and one is for when a parser is asked to fill
in an attribute given as an out-arg.

----

```c++
template<typename T> // int, long, etc.
struct int_parser {
    template<class I, class S>
    T call(I & first, S last, ...) {
        T retval;
        call(first, last, ..., retval);
        return retval;
    }
    template<class I, class S, class Attribute> // Not T!
    void call(I & first, S last, ..., Attribute & attr) {
        // Do parsing here; assign result to 'attr'.
    }
};
```

----

### Attribute generation

----

Let's talk briefly about what parsers Parser provides, and what semantic
actions they produce.

This is not a comprehensive list!
<!-- .element: class="fragment" -->

----

Whitespace and related special parsers: `eps`, `eoi`, `eol`, `ws`, `blank`.
The last two produce the matched character, the others no attribute at all.
`eps` is often used as an anchor for a sematic action, and you can give it a
condition like `eps(cond)`.

----

Character parsers.  Character classes: `control`, `digit`, `punct`,
`hex_digit`, `lower`, `upper`.  Individual characters: `char_`, `char_('a')`,
`char_('a', 'z')`, `char_("abcdef")`.  These each produce the single matched
character.  The type of the character depends on the value type of the range
parsed.

----

The string parser, `string("foo")`.  Matches the exact string given, and
produces that string as a `std::string`.

----

The literal parsers.  `lit('c')`, `lit("str")`, or just `'c'` or `"str"` when
used with an operator overload.  No attribute.

----

The numeric parsers `uint_`, `int_`, `double_`, etc.  Produce the type implied
by the name.  You can specify the number of digits allowed for the integral
type parsers.

----

Operations:

```c++
constexpr auto p00 = a >> b; // (or a > b) sequence; tuple
constexpr auto p01 = a | b;  // alternative; variant
constexpr auto p02 = a || b; // permutation; tuple
constexpr auto p03 = *a;     // Kleene star; vector
constexpr auto p04 = +a;     // one or more; vector
```

----

```c++
constexpr auto p04 = -a;    // zero or one/optional; optional
constexpr auto p05 = a % b; // b-delimited list of a;
                            // attribute of *a
constexpr auto p06 = &a;    // assertion; no attribute
constexpr auto p07 = !a;    // not-assertion; no attribute
constexpr auto p08 = a - b; // !b >> a
```

----

Attribute types collapse to prevent degeneracies, too.  `std::vector<none>`
collapses to `none`.  `none` does not appear in a `tuple`.  `tuple<T>` becomes
`T`. `tuple<>` becomes `none`.

----

```c++
constexpr auto p09 = bp::int_;            // int
constexpr auto p10 = bp::int_ >> bp::eps; // int
```

----

```c++
// tuple<int, double>
constexpr auto p11 = bp::int_ >> bp::double_;
// std::variant<int, double>
constexpr auto p12 = bp::int_ | bp::double_;
// std::optional<int>
constexpr auto p13 = bp::int_ | bp::eps;
```

----

```c++
// std::vector<int>
constexpr auto p14 = +bp::int_ >> bp::int_;
```

----

There are a lot of rules for how attributes get generated.  Parser has tried
to keep the set of rules manageable and easily-described.

There are also rules about how a parser's generated attribute can be mapped
onto an attribute out-arg given to that parser.
<!-- .element: class="fragment" -->

----

An attribute `Attr attr` is "compatible" with an out-argument `Out & out` if:

- `out = std::move(attr)` is well-formed;
- `Attr` is a tuple, `Out` is an aggregate (or vice versa), and there is a mapping; or
- `Attr` is a tuple, and `apply(Out::Out, attr)` is well-formed.

----

If `Out & out` is some kind of container (has `begin()`, `end()`, and
`insert(pos, x)`), `Attr attr` is compatible if `Attr` is a container,
optional, or container-in-an-optional whose `value_type` can be inserted into
`out`.

The insertion might use the notion of compatibility from the previous slide.
<!-- .element: class="fragment" -->

----

Back to our initial example:

```c++
auto const result =
    bp::parse(argv[1], bp::double_ % ',', bp::ws);
if (result) {
    for (double x : *result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

Out-arg instead:

```c++
std::vector<double> result;
bool const success =
    bp::parse(argv[1], bp::double_ % ',', bp::ws, result);
if (success) {
    for (double x : result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

Change the out-arg to a set:

```c++
std::set<double> result;
bool const success =
    bp::parse(argv[1], bp::double_ % ',', bp::ws, result);
if (success) {
    for (double x : result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

```c++
struct thingy { int i; double d; };
thingy t;
bool const success = bp::parse(
    "42 13.0", bp::int_ >> bp::double_, bp::ws, t);
```

----

```c++
struct other_thingy {
    other_thingy() = default;
    other_thingy(int i, double d) : i_(i), d_(d) {}
private:
    int i_;
    double d_;
};
other_thingy ot;
bool const success = bp::parse(
    "42 13.0", bp::int_ >> bp::double_, bp::ws, ot);
```

----

### Semantic actions

----

A semantic action is a function that gets attached to a parser, and gets
called when the parser succeeds.

----

This is similar to how you can associate a bit of C code with a certain part
of your parse in an extrinsic tool like `lex`/`flex`.

From the GNU `flex` docs:
```terminal
%%
username    printf( "%s", getlogin() );
```

----

In Parser, you use `operator[]`.

```c++
constexpr auto parser_with_action = parser[action];
```

`action` must be some invocable.  Attaching an action makes the parser's
attribute `none`.

----

The signature of a semantic action is usually `void (auto &)`:

```c++
auto action = [](auto & ctx) { /* ... */ };
```

There are more compact forms that apply to common cases of actions you use
with rules, but the form here always works.

----

Here is a concrete example.

```c++
std::vector<double> result;
auto push_back = [&](auto & ctx) {
    result.push_back(_attr(ctx));
};
```

----

```c++
bool const success = bp::parse(
    argv[1], bp::double_[push_back] % ',', bp::ws);
if (success) {
    for (double x : result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

This is a completely different way to get attributes out of a parser -- via
side effect.

I don't recommend this.  It's much better to write parsers that produce the
right attribute without your having to write semantic actions.
<!-- .element: class="fragment" -->

----

Where you put the action is important.  The action for `bp::double_[a] % ','`
is completely different from the one you'd use for `(bp::double_ % ',')[a]`.

----

### Rules

----

A rule is a kind of parser.  However, rules also have some extra features that
other parsers do not.

----

A rule is associated with a tag-type.  The rule does its parse simply by
calling a function called `parse_rule()`, using the associated tag-type.  The
rule does not contain any parsers per se; the `parse_rule()` function must do
the actual parsing.

You don't need to define `parse_rule()` for a particular rule to use; there's
a macro that does it.
<!-- .element: class="fragment" -->

----

```c++
// Defines the rule itself.  We still don't have the right
// parse_rule() overloads yet.
constexpr bp::rule<struct ints_tag, std::vector<int>> ints =
    "a comma-delimited list of integers";

// Defines a parser with a suspiciously similar name to the
// rule above.  Still no parse_rule().
constexpr auto ints_def = bp::int_ % ',';

// Defines two overloads of parse_rule(); the first
// parameter is int_tag *.  The body uses ints_def to
// parse.
BOOST_PARSER_DEFINE_RULES(ints)
```

----

Since we defined our rule `ints` without any parsing logic in it, the logic we
later use with `ints` is allowed to refer to `ints`.  This is how we enable
recursive rules, and mutually recursive sets of rules.

----

There are other reasons to write rules.  You write a rule when you want to:

- fix the attribute type produced by a parser to something other than the default;
- create a parser that produces useful diagnostic text;
- create a recursive rule;
- create a set of mutually-recursive parsers; or
- do callback parsing.

----

Perhaps the most important function of a rule is organizational.  I tend to
write rules for the major parts of my big parsers.  I test each one in
isolation, and build more complex parsers out of them.

----

Back to our initial example:

```c++
auto const result =
    bp::parse(argv[1], bp::double_ % ',', bp::ws);
if (result) {
    for (double x : *result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

```c++
std::set<int> result;
bool const success =
    bp::parse(argv[1], bp::double_ % ',', bp::ws, result);
if (success) {
    for (double x : result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

```c++
std::set<int> result;
// Error: ill-formed!
bool const success =
    bp::parse(argv[1], ints, bp::ws, result);
if (success) {
    for (double x : result)
        std::cout << x << "\n";
} else {
    std::cout << "Parse failed.\n";
}
```

----

The Spirit X3 rule problem, revisited.

```c++
namespace x3 = boost::spirit::x3;
using ints_type = x3::rule<class ints, std::vector<int>>;
BOOST_SPIRIT_DECLARE(ints_type);

ints_type ints = "ints";
constexpr auto ints_def = x3::int_ % ',';
BOOST_SPIRIT_DEFINE(ints);
```

----

There is no way to turn off the loose attribute matching X3, not even with a
rule.

Parser enforces the attribute type you give to a rule.

When you write an exact type in your code, the rest of the code should honor
that decision.

----

### Higher-order parsers

----

- `repeat(n)[p]`
- `repeat(min, max)[p]`

These do what you expect; they match exactly `n` times, or no less than `min`
times and no more than `max` times, respectively.

----

`if_(cond)[p]`

Applies `p` to the input if `cond` is `true`; fails to parse otherwise.
Equivalent to `eps(cond) >> p`.

----

`switch_(x)(a, p1)(b, p2)`

Applies `p1` if `x == a`, `p2` if `x == b`.  Equivalent to `eps(x == a) >> p1
| eps(x == b) >> p2`.

----

In any of the higher-order parsers, the values and/or predicates can depend on
the state of the parse.  The values are "resolved" at the point of evaluation.

This means that if a value `X` is a callable that takes a context object, the
resolved value is `X(ctx)`.  Otherwise, the value is just `X`.
<!-- .element: class="fragment" -->

----

### Quoted string parser

----

- `quoted_string`
- `quoted_string('!')`
- `quoted_string("'\"")`
- `quoted_string("'\"", symbols)`

Matches a quoted string, using the given quote-character, or a list of
possible quote characters, and an optional symbol table for escape sequences.

----

### Directives

----

<ul>
<li>`omit[p]`: Don't generate attributes</li>
<li>`raw[p]`: Generate the subrange that `p` matches</li>
<!-- .element: class="fragment" -->
<li>`string_view[p]`: Generate the `std::basic_string_view&lt;CharT>` that `p` matches</li>
<!-- .element: class="fragment" -->
</ul>

----

<ul>
<li>`no_case[p]`: Match case-insensitively (using Unicode case folding)</li>
<li>`lexeme[p]`: Disable the skipper</li>
<!-- .element: class="fragment" -->
<li>`skip[p]`: Re-enable or change the skipper</li>
<!-- .element: class="fragment" -->
</ul>

----

<ul>
<li>`merge[p]`: Force all subparsers to use the same attribute object</li>
<li>`separate[p]`: Force all subparsers to use different attribute objects</li>
<!-- .element: class="fragment" -->
</ul>

----

```c++
// Attribute type std::tuple<std::string, std::string>
auto const parser1 = bp::string("abc") >> bp::string("def");
```

```c++
// Attribute type std::string
auto const parser2 =
    bp::merge[bp::string("abc") >> bp::string("def")];
```
<!-- .element: class="fragment" -->

----

```c++
// Attribute type std::vector<int>
auto const parser1 = +bp::int_ >> bp::int_;
```

```c++
// Attribute type std::tuple<std::vector<int>, int>
auto const parser2 = bp::separate[+bp::int_ >> bp::int_];
```
<!-- .element: class="fragment" -->

----

### Unicode support

----

TODO

----

### Diagnostics

----

TODO

----

### Trace

----

TODO

----

### Debugging support

----

TODO

----

TODO

----

### Algorithms and ranges

TODO

<!--
Range-y stuff:

Part 1: Overview of making a range
- the view, and the V base_ it operates on
- the range adaptor that makes the view
- all_t, and its use in deduction guides
- std::ranges::range_adaptor_closure and std::bind_back()

Part 2: all_t
- purpose is to adapt viewable_ranges to views (and not to touch views)
- ref_view
  - note ctors, base(), begin()/end(), no begin() const/end() const
- owning_view
  - note ctors, base(), begin()/end(), begin() const/end() const
- the 'all' range adaptor
  - can_ref_view

Part 3: replace/replace_view
- replace_view
  - note ctors, base(), begin()/end(), begin() const/end() const
  - replace_view::sentinel
  - replace_view::iterator
    - maybe_const
    - op++, op*
    - either_iterator, concatable
- the 'replace' range adaptor
  - R may be a viewable_range or a pointer to a null-terminated string
  - same with the replacement
  - can_replace_view
  - to_range
    - range_utf_format_v
    - as_utfN
    - is_bounded_array and null terminators

- Hard-to-understand concept error messages due to non-const either_iterator::op*().
-->

----

## Questions?

<span class="fragment fade-in">
https://github.com/tzlaine/parser <br>
</span>

            </script>
            </section>
        </div>
    </div>

    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/notes/notes.js"></script>
    <script src="reveal.js/plugin/markdown/markdown.js"></script>
    <script src="reveal.js/plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            slideNumber: "c/t",
            hash: true,
            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
        });
    </script>
    </body>
</html>
